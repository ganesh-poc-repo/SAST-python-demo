Below is an example YAML workflow for your Python repository that uses a `pyproject.toml` dependency file. This workflow assumes you're using Poetry as your package manager.

```yml
name: CI Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python environment
        uses: actions/setup-python@v3
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          poetry install

      - name: Run build and tests
        run: |
          poetry run python -m pytest --cov=.

      - name: Run linter
        run: |
          poetry run flake8 . --count | grep 'Found 1 errors' || exit 0
```

Explanation:

*   The `on` section specifies when the workflow should be triggered. In this case, it's triggered on push events to the `main` branch.
*   The `jobs` section defines a single job called `build-and-test`.
*   The `runs-on` step specifies that the job will run on an `ubuntu-latest` environment.
*   The first `step` in the workflow checks out your repository using GitHub Actions' built-in `checkout` action. It uses the `fetch-depth: 0` option to fetch all history, including the most recent commits.
*   The second step sets up a Python environment using the `setup-python` action. This step can be customized based on the requirements of your project. For this example, it uses the `3.9` version of Python.
*   The third step installs dependencies using Poetry's `install` command.
*   The fourth step runs your build and tests using the `poetry run python -m pytest --cov=.` command. This assumes that your project uses Poetry for dependency management and that you have a test suite written in Python. The `--cov=` option is used to enable code coverage reporting, which can help catch bugs.
*   Finally, the fifth step runs a linter (in this case, flake8) on your repository using the `poetry run flake8 . --count` command. If any errors are found, it will exit with a non-zero status.

This is just an example and may need to be adjusted based on your specific project requirements and the structure of your repositories.